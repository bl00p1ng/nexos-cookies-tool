import CookieDetector from './CookieDetector.js';

/**
 * Controlador principal de navegaci√≥n
 * Coordina la navegaci√≥n autom√°tica entre sitios web y recolecci√≥n de cookies
 * Soporta m√∫ltiples perfiles simult√°neos
 */
class NavigationController {
    constructor(databaseManager, configManager) {
        this.databaseManager = databaseManager;
        this.configManager = configManager;
        this.cookieDetector = new CookieDetector();
        this.activeSessions = new Map();
        this.globalStats = {
            totalSessions: 0,
            completedSessions: 0,
            totalCookiesCollected: 0,
            totalSitesVisited: 0,
            errors: 0,
            startTime: null
        };
    }

    /**
     * Inicia m√∫ltiples sesiones de navegaci√≥n en paralelo
     * @param {Array|string} profileIds - Array de IDs o ID √∫nico de perfil
     * @param {number} targetCookies - Cantidad objetivo de cookies por perfil
     * @returns {Promise<Object>} Resultado agregado de todas las sesiones
     */
    async startMultipleNavigationSessions(profileIds, targetCookies = null) {
        const profiles = Array.isArray(profileIds) ? profileIds : [profileIds];
        const cookieTarget = targetCookies || this.configManager.getDefaultCookieTarget();
        
        console.log(`üöÄ Iniciando navegaci√≥n con ${profiles.length} perfil(es)`);
        console.log(`üéØ Objetivo por perfil: ${cookieTarget} cookies`);
        console.log(`üìã Perfiles: ${profiles.join(', ')}`);
        
        this.globalStats.totalSessions = profiles.length;
        this.globalStats.startTime = new Date();
        
        // Configurar WAL mode para SQLite (mejora concurrencia)
        await this.setupDatabaseConcurrency();
        
        // Iniciar todas las sesiones en paralelo
        const sessionPromises = profiles.map(profileId => 
            this.startSingleNavigationSession(profileId, cookieTarget)
                .catch(error => {
                    console.error(`‚ùå Error en perfil ${profileId}:`, error.message);
                    this.globalStats.errors++;
                    return {
                        profileId,
                        success: false,
                        error: error.message,
                        cookiesCollected: 0,
                        sitesVisited: 0
                    };
                })
        );
        
        // Mostrar progreso mientras ejecutan
        const progressInterval = setInterval(() => {
            this.showGlobalProgress();
        }, 10000); // Cada 10 segundos
        
        try {
            // Esperar a que terminen todas las sesiones
            const results = await Promise.all(sessionPromises);
            clearInterval(progressInterval);
            
            // Calcular estad√≠sticas finales
            const finalStats = this.calculateFinalStats(results);
            this.showFinalReport(finalStats);
            
            return finalStats;
            
        } catch (error) {
            clearInterval(progressInterval);
            throw error;
        }
    }

    /**
     * Inicia una sesi√≥n de navegaci√≥n individual
     * @param {string} profileId - ID del perfil
     * @param {number} targetCookies - Cantidad objetivo de cookies
     * @returns {Promise<Object>} Resultado de la sesi√≥n
     */
    async startSingleNavigationSession(profileId, targetCookies) {
        const sessionId = `session_${profileId}_${Date.now()}`;
        
        console.log(`üîÑ [${profileId}] Iniciando sesi√≥n...`);
        
        const sessionStats = {
            profileId,
            sessionId,
            targetCookies,
            cookiesCollected: 0,
            sitesVisited: 0,
            startTime: new Date(),
            visitedUrls: new Set(),
            errors: 0,
            currentSite: null
        };
        
        this.activeSessions.set(profileId, sessionStats);
        
        let browserInstance = null;
        
        try {
            // Iniciar perfil de AdsPower
            browserInstance = await this.initializeProfile(profileId);
            const { page } = browserInstance;
            
            // Obtener cookies iniciales
            const initialCookies = await this.cookieDetector.getCookieCount(page);
            sessionStats.cookiesCollected = initialCookies;
            
            console.log(`üìä [${profileId}] Cookies iniciales: ${initialCookies}`);
            
            // Registrar sesi√≥n en base de datos
            await this.registerSession(sessionStats);
            
            // Bucle principal de navegaci√≥n
            let attempts = 0;
            const maxAttempts = 100; // L√≠mite de seguridad
            
            while (sessionStats.cookiesCollected < targetCookies && attempts < maxAttempts) {
                attempts++;
                
                try {
                    // Obtener sitio web aleatorio no visitado
                    const excludedUrls = Array.from(sessionStats.visitedUrls);
                    const website = await this.databaseManager.getRandomWebsite(excludedUrls);
                    
                    if (!website) {
                        console.log(`‚ö†Ô∏è [${profileId}] No hay m√°s sitios disponibles`);
                        break;
                    }
                    
                    sessionStats.currentSite = website.domain;
                    console.log(`üåê [${profileId}] Navegando a: ${website.domain}`);
                    
                    // Navegar al sitio y procesar cookies
                    const siteResult = await this.processSiteVisit(page, website, sessionStats);
                    
                    // Actualizar estad√≠sticas
                    sessionStats.cookiesCollected = siteResult.cookiesAfter;
                    sessionStats.sitesVisited++;
                    sessionStats.visitedUrls.add(website.url);
                    
                    // Registrar visita en base de datos
                    await this.registerSiteVisit(sessionStats, website, siteResult);
                    
                    // Mostrar progreso individual
                    const progress = Math.min((sessionStats.cookiesCollected / targetCookies) * 100, 100);
                    console.log(`üìà [${profileId}] Progreso: ${sessionStats.cookiesCollected}/${targetCookies} cookies (${progress.toFixed(1)}%)`);
                    
                    // Peque√±a pausa entre sitios (comportamiento humano)
                    await this.sleep(this.randomBetween(2000, 5000));
                    
                } catch (siteError) {
                    console.error(`‚ùå [${profileId}] Error en sitio:`, siteError.message);
                    sessionStats.errors++;
                    
                    // Continuar con siguiente sitio
                    await this.sleep(1000);
                }
            }
            
            // Marcar sesi√≥n como completada
            sessionStats.endTime = new Date();
            await this.completeSession(sessionStats);
            
            console.log(`‚úÖ [${profileId}] Sesi√≥n completada: ${sessionStats.cookiesCollected} cookies`);
            
            return {
                profileId,
                success: true,
                cookiesCollected: sessionStats.cookiesCollected,
                sitesVisited: sessionStats.sitesVisited,
                duration: sessionStats.endTime - sessionStats.startTime,
                targetReached: sessionStats.cookiesCollected >= targetCookies
            };
            
        } catch (error) {
            console.error(`‚ùå [${profileId}] Error en sesi√≥n:`, error.message);
            throw error;
            
        } finally {
            this.activeSessions.delete(profileId);
            
            if (browserInstance) {
                try {
                    await this.cleanupProfile(profileId, browserInstance);
                } catch (cleanupError) {
                    console.error(`‚ö†Ô∏è [${profileId}] Error en cleanup:`, cleanupError.message);
                }
            }
        }
    }

    /**
     * Inicializa un perfil de AdsPower
     * @param {string} profileId - ID del perfil
     * @returns {Promise<Object>} Instancia del navegador
     */
    async initializeProfile(profileId) {
        // Obtener AdsPowerManager desde main.js (se pasa como dependencia)
        const adsPowerManager = global.adsPowerManager;
        if (!adsPowerManager) {
            throw new Error('AdsPowerManager no disponible');
        }
        
        return await adsPowerManager.startProfile(profileId);
    }

    /**
     * Procesa la visita a un sitio web espec√≠fico
     * @param {Object} page - P√°gina de Playwright
     * @param {Object} website - Datos del sitio web
     * @param {Object} sessionStats - Estad√≠sticas de la sesi√≥n
     * @returns {Promise<Object>} Resultado de la visita
     */
    async processSiteVisit(page, website, sessionStats) {
        const cookiesBefore = await this.cookieDetector.getCookieCount(page);
        let visitSuccess = false;
        let errorMessage = null;
        
        try {
            // Navegar al sitio
            await page.goto(website.url, { 
                waitUntil: 'domcontentloaded',
                timeout: 30000 
            });
            
            // Peque√±a espera para que cargue completamente
            await this.sleep(2000);
            
            // Intentar aceptar cookies
            const cookieResult = await this.cookieDetector.acceptCookies(page);
            
            if (cookieResult.success) {
                console.log(`üç™ [${sessionStats.profileId}] Cookies aceptadas en ${website.domain}`);
            }
            
            // Simular navegaci√≥n b√°sica (scroll, tiempo en p√°gina)
            await this.simulateBasicNavigation(page);
            
            visitSuccess = true;
            
        } catch (error) {
            console.error(`‚ö†Ô∏è [${sessionStats.profileId}] Error en ${website.domain}:`, error.message);
            errorMessage = error.message;
        }
        
        const cookiesAfter = await this.cookieDetector.getCookieCount(page);
        const cookiesGained = cookiesAfter - cookiesBefore;
        
        if (cookiesGained > 0) {
            console.log(`üìà [${sessionStats.profileId}] +${cookiesGained} cookies de ${website.domain}`);
        }
        
        return {
            cookiesBefore,
            cookiesAfter,
            cookiesGained,
            success: visitSuccess,
            error: errorMessage,
            duration: 0
        };
    }

    /**
     * Simula navegaci√≥n humana b√°sica
     * @param {Object} page - P√°gina de Playwright
     */
    async simulateBasicNavigation(page) {
        try {
            // Scroll aleatorio
            const scrollAmount = this.randomBetween(200, 800);
            await page.evaluate((amount) => {
                window.scrollBy(0, amount);
            }, scrollAmount);
            
            // Tiempo en p√°gina
            const timeOnPage = this.randomBetween(3000, 8000);
            await this.sleep(timeOnPage);
            
        } catch (error) {
            // Ignorar errores de simulaci√≥n
        }
    }

    /**
     * Configura la base de datos para mejor concurrencia
     */
    async setupDatabaseConcurrency() {
        try {
            // Activar WAL mode para mejor concurrencia
            await this.databaseManager.db.runAsync('PRAGMA journal_mode=WAL');
            await this.databaseManager.db.runAsync('PRAGMA synchronous=NORMAL');
            await this.databaseManager.db.runAsync('PRAGMA cache_size=10000');
            await this.databaseManager.db.runAsync('PRAGMA temp_store=memory');
            
            console.log('üîß Base de datos configurada para concurrencia');
        } catch (error) {
            console.warn('‚ö†Ô∏è No se pudo optimizar la base de datos:', error.message);
        }
    }

    /**
     * Registra una nueva sesi√≥n en la base de datos
     */
    async registerSession(sessionStats) {
        try {
            await this.databaseManager.db.runAsync(`
                INSERT INTO navigation_sessions 
                (session_id, profile_id, target_cookies, started_at, status) 
                VALUES (?, ?, ?, ?, 'running')
            `, [
                sessionStats.sessionId,
                sessionStats.profileId,
                sessionStats.targetCookies,
                sessionStats.startTime.toISOString()
            ]);
        } catch (error) {
            console.warn(`‚ö†Ô∏è Error registrando sesi√≥n ${sessionStats.profileId}:`, error.message);
        }
    }

    /**
     * Registra una visita a sitio en la base de datos
     */
    async registerSiteVisit(sessionStats, website, siteResult) {
        try {
            await this.databaseManager.db.runAsync(`
                INSERT INTO site_visits 
                (session_id, website_id, cookies_before, cookies_after, success, error_message, visited_at) 
                VALUES (?, ?, ?, ?, ?, ?, ?)
            `, [
                sessionStats.sessionId,
                website.id,
                siteResult.cookiesBefore,
                siteResult.cookiesAfter,
                siteResult.success,
                siteResult.error,
                new Date().toISOString()
            ]);
            
            // Actualizar estad√≠sticas del sitio web
            await this.databaseManager.updateWebsiteStats(website.url, siteResult.cookiesGained);
            
        } catch (error) {
            console.warn(`‚ö†Ô∏è Error registrando visita:`, error.message);
        }
    }

    /**
     * Completa una sesi√≥n en la base de datos
     */
    async completeSession(sessionStats) {
        try {
            await this.databaseManager.db.runAsync(`
                UPDATE navigation_sessions 
                SET completed_at = ?, cookies_collected = ?, sites_visited = ?, status = 'completed'
                WHERE session_id = ?
            `, [
                sessionStats.endTime.toISOString(),
                sessionStats.cookiesCollected,
                sessionStats.sitesVisited,
                sessionStats.sessionId
            ]);
        } catch (error) {
            console.warn(`‚ö†Ô∏è Error completando sesi√≥n:`, error.message);
        }
    }

    /**
     * Limpia un perfil de AdsPower
     */
    async cleanupProfile(profileId, browserInstance) {
        const adsPowerManager = global.adsPowerManager;
        if (adsPowerManager) {
            await adsPowerManager.stopProfile(profileId);
        }
    }

    /**
     * Muestra progreso global de todas las sesiones
     */
    showGlobalProgress() {
        const activeSessions = Array.from(this.activeSessions.values());
        if (activeSessions.length === 0) return;
        
        console.log('\nüìä PROGRESO GLOBAL:');
        console.log('‚ïê'.repeat(60));
        
        activeSessions.forEach(session => {
            const progress = Math.min((session.cookiesCollected / session.targetCookies) * 100, 100);
            const progressBar = this.createProgressBar(progress);
            
            console.log(`[${session.profileId}] ${progressBar} ${progress.toFixed(1)}% (${session.cookiesCollected}/${session.targetCookies})`);
            if (session.currentSite) {
                console.log(`    üìç Actual: ${session.currentSite}`);
            }
        });
        
        console.log('‚ïê'.repeat(60));
    }

    /**
     * Calcula estad√≠sticas finales agregadas
     */
    calculateFinalStats(results) {
        const successful = results.filter(r => r.success);
        const totalCookies = results.reduce((sum, r) => sum + r.cookiesCollected, 0);
        const totalSites = results.reduce((sum, r) => sum + r.sitesVisited, 0);
        const avgDuration = results.reduce((sum, r) => sum + (r.duration || 0), 0) / results.length;
        
        return {
            totalProfiles: results.length,
            successfulProfiles: successful.length,
            failedProfiles: results.length - successful.length,
            totalCookiesCollected: totalCookies,
            totalSitesVisited: totalSites,
            averageCookiesPerProfile: totalCookies / results.length,
            averageDurationMinutes: avgDuration / (1000 * 60),
            successRate: (successful.length / results.length) * 100,
            results: results,
            duration: Date.now() - this.globalStats.startTime
        };
    }

    /**
     * Muestra reporte final detallado
     */
    showFinalReport(stats) {
        console.log('\nüéâ REPORTE FINAL DE NAVEGACI√ìN');
        console.log('‚ïê'.repeat(80));
        console.log(`üìä Perfiles procesados: ${stats.totalProfiles}`);
        console.log(`‚úÖ Exitosos: ${stats.successfulProfiles}`);
        console.log(`‚ùå Fallidos: ${stats.failedProfiles}`);
        console.log(`üç™ Total cookies recolectadas: ${stats.totalCookiesCollected}`);
        console.log(`üåê Total sitios visitados: ${stats.totalSitesVisited}`);
        console.log(`üìà Promedio cookies/perfil: ${stats.averageCookiesPerProfile.toFixed(0)}`);
        console.log(`‚è±Ô∏è  Duraci√≥n total: ${(stats.duration / 1000 / 60).toFixed(1)} minutos`);
        console.log(`‚ú® Tasa de √©xito: ${stats.successRate.toFixed(1)}%`);
        
        console.log('\nüìã DETALLE POR PERFIL:');
        stats.results.forEach(result => {
            const status = result.success ? '‚úÖ' : '‚ùå';
            const target = result.targetReached ? 'üéØ' : '‚è≥';
            console.log(`   ${status} ${target} [${result.profileId}] ${result.cookiesCollected} cookies, ${result.sitesVisited} sitios`);
        });
        
        console.log('‚ïê'.repeat(80));
    }

    /**
     * Crea una barra de progreso visual
     */
    createProgressBar(percentage, width = 20) {
        const filled = Math.round((percentage / 100) * width);
        const empty = width - filled;
        return '‚ñà'.repeat(filled) + '‚ñë'.repeat(empty);
    }

    /**
     * Genera n√∫mero aleatorio entre min y max
     */
    randomBetween(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    /**
     * Funci√≥n sleep/delay
     */
    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}

export default NavigationController;